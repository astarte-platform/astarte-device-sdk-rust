// This file is part of Astarte.
//
// Copyright 2024 SECO Mind Srl
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

//! Handles stored retention for the connections.

use std::{
    array::TryFromSliceError,
    borrow::Cow,
    fmt::Display,
    hash::Hash,
    sync::{
        atomic::{AtomicU32, Ordering},
        Arc,
    },
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use async_trait::async_trait;
use futures::{stream::BoxStream, TryStreamExt};
use tracing::{error, warn};

use crate::{
    error::{DynError, Report},
    interface::{Reliability, Retention},
    interfaces::Interfaces,
    validate::{ValidatedIndividual, ValidatedObject},
};

pub(crate) mod sqlite;

/// Error returned by the retention.
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum RetentionError {
    /// Couldn't store the publish information.
    #[error("couldn't store publish for {interface}/{path}:{major_version}")]
    Store {
        /// The interface we are publishing on.
        interface: String,
        /// The endpoint of the interface.
        path: String,
        /// Major version of the interface.
        major_version: i32,
        /// The error generated by the store.
        #[source]
        backtrace: DynError,
    },
    /// Couldn't mark the publish as received.
    #[error("couldn't mark publish as received with id {id}")]
    Received {
        /// Id of the publish saved in the store.
        id: Id,
        /// The error generated by the store.
        #[source]
        backtrace: DynError,
    },
    /// Couldn't get all the publish information.
    #[error("couldn't get all publishes")]
    All {
        /// The error generated by the store.
        #[source]
        backtrace: DynError,
    },
    /// Couldn't delete the publish.
    #[error("couldn't delete the publish with id {id}")]
    Delete {
        /// Id of the publish saved in the store.
        id: Id,
        /// The error generated by the store.
        #[source]
        backtrace: DynError,
    },
}

impl RetentionError {
    pub(crate) fn store(info: &PublishInfo<'_>, backstrace: impl Into<DynError>) -> Self {
        Self::Store {
            backtrace: backstrace.into(),
            interface: info.interface.to_string(),
            path: info.path.to_string(),
            major_version: info.version_major,
        }
    }

    pub(crate) fn received(id: Id, backstrace: impl Into<DynError>) -> Self {
        Self::Received {
            id,
            backtrace: backstrace.into(),
        }
    }

    pub(crate) fn all(backstrace: impl Into<DynError>) -> Self {
        Self::All {
            backtrace: backstrace.into(),
        }
    }

    pub(crate) fn delete(id: Id, backstrace: impl Into<DynError>) -> Self {
        Self::Delete {
            id,
            backtrace: backstrace.into(),
        }
    }
}

/// Publish information to be stored.
#[derive(Debug, Clone, PartialEq)]
pub struct PublishInfo<'a> {
    pub(crate) interface: Cow<'a, str>,
    pub(crate) path: Cow<'a, str>,
    pub(crate) version_major: i32,
    pub(crate) reliability: Reliability,
    pub(crate) expiry: Option<Duration>,
    pub(crate) value: Cow<'a, [u8]>,
}

impl<'a> PublishInfo<'a> {
    pub(crate) const fn from_ref(
        interface: &'a str,
        path: &'a str,
        version_major: i32,
        reliability: Reliability,
        retention: Retention,
        value: &'a [u8],
    ) -> Self {
        debug_assert!(retention.is_stored());

        Self {
            interface: Cow::Borrowed(interface),
            path: Cow::Borrowed(path),
            version_major,
            reliability,
            expiry: retention.expiry(),
            value: Cow::Borrowed(value),
        }
    }

    fn from_individual(individual: &'a ValidatedIndividual, value: &'a [u8]) -> Self {
        Self::from_ref(
            &individual.interface,
            &individual.path,
            individual.version_major,
            individual.reliability,
            individual.retention,
            value,
        )
    }

    fn from_obj(obj: &'a ValidatedObject, value: &'a [u8]) -> Self {
        Self::from_ref(
            &obj.interface,
            &obj.path,
            obj.version_major,
            obj.reliability,
            obj.retention,
            value,
        )
    }
}

/// Trait to store application packet for a connection.
///
/// A store wants to implement this retention to implement the interfaces with retention stored for
/// a connection.
#[async_trait]
pub trait StoredRetention: Clone + Send + Sync {
    /// Store a publish returning the id to access the publish in the future.
    async fn store_publish(&self, publish: PublishInfo<'_>) -> Result<Id, RetentionError>;

    /// It will mark the stored publish as received.
    async fn mark_received(&self, id: &Id) -> Result<(), RetentionError>;

    /// Deletes a publish from the store.
    async fn delete_publish(&self, id: &Id) -> Result<(), RetentionError>;

    /// Resend all the packets.
    async fn all_publishes(
        &self,
    ) -> Result<BoxStream<Result<(Id, PublishInfo<'static>), RetentionError>>, RetentionError>;
}

/// Utility trait that can be used to simplify the boilerplate for the connections.
#[async_trait]
pub(crate) trait StoredRetentionExt: StoredRetention {
    async fn store_publish_individual(
        &self,
        individual: &ValidatedIndividual,
        value: &[u8],
    ) -> Result<Id, RetentionError> {
        let publish = PublishInfo::from_individual(individual, value);

        self.store_publish(publish).await
    }

    async fn store_publish_obj(
        &self,
        obj: &ValidatedObject,
        value: &[u8],
    ) -> Result<Id, RetentionError> {
        let publish = PublishInfo::from_obj(obj, value);

        self.store_publish(publish).await
    }

    /// Removes the outdated interfaces from the introspection
    async fn cleanup_introspection(&self, interfaces: &Interfaces) -> Result<(), RetentionError> {
        self.all_publishes()
            .await?
            .try_filter_map(|(id, info)| {
                let Some(interface) = interfaces.get(&info.interface) else {
                    return futures::future::ready(Ok(Some(id)));
                };

                if interface.version_major() != info.version_major {
                    return futures::future::ready(Ok(Some(id)));
                }

                futures::future::ready(Ok(None))
            })
            .try_for_each(|id| async move { self.delete_publish(&id).await })
            .await?;

        Ok(())
    }
}

impl<T: StoredRetention> StoredRetentionExt for T {}

/// Un-constructable type for a default retention.
///
/// This should be the never type [`!`] in the future.
#[derive(Clone, Copy)]
pub struct Missing {
    _marker: (),
}

#[async_trait]
impl StoredRetention for Missing {
    async fn store_publish(&self, _publish: PublishInfo<'_>) -> Result<Id, RetentionError> {
        unreachable!("the type is Un-constructable");
    }

    async fn mark_received(&self, _packet: &Id) -> Result<(), RetentionError> {
        unreachable!("the type is Un-constructable");
    }

    async fn all_publishes(
        &self,
    ) -> Result<BoxStream<Result<(Id, PublishInfo<'static>), RetentionError>>, RetentionError> {
        unreachable!("the type is Un-constructable");
    }

    async fn delete_publish(&self, _id: &Id) -> Result<(), RetentionError> {
        unreachable!("the type is Un-constructable");
    }
}

/// Id of a publish
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[must_use]
pub struct Id {
    timestamp: TimestampMillis,
    counter: u32,
}

impl Id {
    pub(crate) fn from_row(timestamp: &[u8], counter: u32) -> Result<Self, TryFromSliceError> {
        let timestamp = timestamp.try_into()?;

        Ok(Self { timestamp, counter })
    }
}

impl Display for Id {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}-{}", self.timestamp, self.counter)
    }
}

/// Wrapper to a u128 to easily convert it into bytes.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TimestampMillis(pub u128);

impl TimestampMillis {
    /// Get the current system time.
    pub fn now() -> Self {
        let timestamp = match SystemTime::now().duration_since(UNIX_EPOCH) {
            Ok(t) => t.as_millis(),
            Err(err) => {
                warn!(error = %Report::new(&err), "untrasted system clock, time returned before unix epoch");

                // Let's use the positive duration, this will wrap around in weird ways if its,
                // close to the unix epoch
                err.duration().as_millis()
            }
        };

        Self(timestamp)
    }

    /// Standardize the conversion of the timestamp to bytes.
    pub fn to_bytes(&self) -> [u8; 16] {
        self.0.to_be_bytes()
    }
}

impl TryFrom<&[u8]> for TimestampMillis {
    type Error = TryFromSliceError;

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let bytes = value.try_into()?;
        let timestamp = u128::from_be_bytes(bytes);

        Ok(Self(timestamp))
    }
}

impl Display for TimestampMillis {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        <u128 as Display>::fmt(&self.0, f)
    }
}

impl std::ops::DerefMut for TimestampMillis {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl std::ops::Deref for TimestampMillis {
    type Target = u128;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

/// Context to create a unique [`Id`].
#[derive(Debug, Clone)]
pub struct Context {
    counter: Arc<AtomicU32>,
}

impl Context {
    /// Create a new context
    pub fn new() -> Self {
        Self {
            counter: Arc::new(AtomicU32::new(0)),
        }
    }

    /// Returns the next unique id.
    pub fn next(&self) -> Id {
        let timestamp = TimestampMillis::now();

        // We want the values to be unique, this will wrap around, but it will never wrap on the
        // same ms
        let counter = self.counter.fetch_add(1, Ordering::AcqRel);

        Id { timestamp, counter }
    }
}

impl Default for Context {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashSet;

    use super::*;

    #[test]
    fn id_should_be_unique() {
        const NUM: usize = 5;
        let ctx = Context::new();

        let (tx, rx) = std::sync::mpsc::sync_channel::<Id>(NUM);

        for _ in 0..NUM {
            std::thread::spawn({
                let ctx = ctx.clone();
                let tx = tx.clone();

                move || {
                    let mut prev = ctx.next();
                    for _i in 0..1000 {
                        let new = ctx.next();

                        tx.send(new).expect("channel closed");

                        assert!(new > prev);

                        prev = new;
                    }
                }
            });
        }

        drop(tx);

        let mut recvd = HashSet::new();
        while let Ok(new) = rx.recv() {
            assert!(recvd.insert(new));
        }
    }
}
